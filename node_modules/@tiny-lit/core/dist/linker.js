import { AttributeExpression, NodeExpression } from './expressions';
import { getNodePath, getNodeByPath, text, TEXT_ELEMENT, MARKER_RE, markerNumber, isNode } from './utils';
function treeWalkerFilter() {
    return NodeFilter.FILTER_ACCEPT;
}
treeWalkerFilter.acceptNode = treeWalkerFilter;
export function linkAttributes(element, linkedExpressions) {
    const attrs = element.attributes;
    let i = attrs.length;
    while (i--) {
        const { name, value, namespaceURI } = attrs.item(i);
        const m = markerNumber(value);
        if (~m) {
            element.removeAttribute(name);
            linkedExpressions[m] = {
                type: AttributeExpression,
                name,
                namespaceURI,
                nodePath: getNodePath(element)
            };
        }
    }
}
export function linkComment(node, linkedExpressions) {
    const m = markerNumber(node.data);
    if (~m) {
        linkedExpressions[m] = {
            type: NodeExpression,
            nodePath: getNodePath(node)
        };
        node.nodeValue = '';
    }
}
export function linkTexts(node, linkedExpressions) {
    let m;
    while ((m = MARKER_RE.exec(node.data)) !== null) {
        const keyNode = text();
        node = node.splitText(m.index);
        node.deleteData(0, m[0].length);
        node.parentNode.insertBefore(keyNode, node);
        linkedExpressions[Number(m[1] || m[2])] = {
            type: NodeExpression,
            nodePath: getNodePath(keyNode)
        };
    }
}
export function linkExpressions(root) {
    const treeWalker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT, treeWalkerFilter, false);
    const linkedExpressions = [];
    while (treeWalker.nextNode()) {
        const node = treeWalker.currentNode;
        if (isNode(node, Node.ELEMENT_NODE)) {
            linkAttributes(node, linkedExpressions);
            if (TEXT_ELEMENT.test(node.tagName)) {
                for (const childNode of node.childNodes) {
                    linkTexts(childNode, linkedExpressions);
                }
            }
        }
        else
            linkComment(node, linkedExpressions);
    }
    return linkedExpressions;
}
export function resolve(fragment, symbols) {
    return symbols.map((symbol) => new symbol.type(getNodeByPath(fragment, symbol.nodePath), symbol.name, symbol.namespaceURI));
}
