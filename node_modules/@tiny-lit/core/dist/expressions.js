import { isNode, replaceRange, isTemplate, isSameTemplate, moveTemplate, text, isPrimitive } from './utils';
import { scheduled } from './scheduler';
export class AttributeExpression {
    constructor(element, name, namespaceURI) {
        this.element = element;
        this.name = name;
        this.namespaceURI = namespaceURI;
        this.requestUpdate = scheduled((newValue) => {
            const { name, element, namespaceURI } = this;
            if ('ownerSVGElement' in element) {
                element.setAttributeNS(namespaceURI, name, newValue);
            }
            else if (name in element) {
                element[name] = newValue;
            }
            else if (typeof newValue !== 'undefined') {
                element.setAttribute(name, newValue);
            }
            else {
                element.hasAttribute(name) && element.removeAttribute(name);
            }
            this.value = newValue;
        });
    }
    update(newValue) {
        if (newValue === this.value)
            return;
        this.requestUpdate(newValue);
    }
}
export class NodeExpression {
    constructor(element) {
        this.requestUpdate = scheduled((newValue) => {
            if (isPrimitive(newValue)) {
                this.updateText(newValue);
            }
            else if (Array.isArray(newValue)) {
                newValue = this.updateArray(newValue);
            }
            else if (isSameTemplate(newValue, this.element)) {
                this.updateTemplate(newValue.values);
            }
            else {
                this.replaceWith(newValue);
            }
            this.value = newValue;
        });
        this.element = this.placeholder = element;
    }
    updateArray(items) {
        this.replaceWith(this.placeholder);
        const templates = this.value instanceof Map ? this.value : new Map();
        let currentNode = this.element;
        const keys = new Set();
        for (let i = 0, l = items.length; i < l; i++) {
            const item = items[i];
            const key = String(item.key || i);
            let template = templates.get(key);
            if (!template) {
                const node = item.create();
                currentNode.parentNode.insertBefore(node, currentNode.nextSibling);
                templates.set(key, (template = item));
            }
            else if (!isSameTemplate(template, item)) {
                replaceRange(item.create(), template.range);
                templates.set(key, (template = item));
            }
            else {
                template.update(item.values);
            }
            if (currentNode.nextSibling !== template.range[0]) {
                moveTemplate(template, currentNode);
            }
            currentNode = template.range[1];
            keys.add(key);
        }
        templates.forEach((template, key, map) => {
            if (!keys.has(key)) {
                template.delete();
                map.delete(key);
            }
        });
        return templates;
    }
    replaceWith(newValue) {
        const { element, value, placeholder } = this;
        if (newValue == null)
            newValue = placeholder;
        if (element !== newValue) {
            if (value instanceof Map) {
                value.forEach((template) => template.delete());
                value.clear();
            }
            this.element = newValue;
            replaceRange(isTemplate(newValue)
                ? newValue.create()
                : newValue, isTemplate(element)
                ? element.range
                : element);
        }
    }
    updateText(value) {
        if (!isNode(this.element, Node.TEXT_NODE)) {
            this.replaceWith(text());
        }
        this.element.textContent = value;
    }
    updateTemplate(values) {
        this.element.update(values);
    }
    update(newValue) {
        if (newValue === this.value)
            return;
        this.requestUpdate(newValue);
    }
}
