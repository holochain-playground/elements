import { linkExpressions, resolve } from './linker';
import { MARKER_PREFIX } from './utils';
const TemplateCache = new WeakMap();
function createCacheEntry(html, context) {
    const template = document.createElement('template');
    template.innerHTML = context ? `<${context}>${html}</${context}>` : html;
    let content = template.content;
    if (context) {
        const range = document.createRange();
        range.selectNodeContents(content.firstChild);
        content = range.extractContents();
    }
    return {
        content,
        expressions: linkExpressions(content)
    };
}
function toHTML(strings) {
    const tagName = `[0-9a-z-]+`, attributeName = `[^<\\s\\0"'>\\/=]+`, attributeValue = `(?:"[^"]*"?|'[^']*'?|[^\\s'">]*)`, attribute = `\\s*${attributeName}(?:\\s*=\\s*${attributeValue})?`, tagOpen = `<(${tagName})(?:${attribute})*\\s*(>?)`;
    const NODE_RE = new RegExp(`^[^]*${tagOpen}|[^]*(>)[^]*|[^]*$`, 'i');
    let isAttribute = false;
    let html = strings[0];
    for (let i = 0, l = strings.length; i < l - 1; i++) {
        const marker = `${MARKER_PREFIX}${i}`;
        const match = strings[i].match(NODE_RE);
        if (match[1]) {
            isAttribute = !match[2];
        }
        else if (match[3]) {
            isAttribute = false;
        }
        html += (isAttribute ? marker : `<!--${marker}-->`) + strings[i + 1];
    }
    return html;
}
export function parseTemplate(strings, context) {
    let cacheEntry = TemplateCache.get(strings);
    if (!cacheEntry) {
        TemplateCache.set(strings, (cacheEntry = createCacheEntry(toHTML(strings), context)));
    }
    const fragment = document.importNode(cacheEntry.content, true);
    const expressions = resolve(fragment, cacheEntry.expressions);
    return {
        fragment,
        expressions
    };
}
