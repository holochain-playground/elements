function createChangeCallback(name) {
    const defaultName = `on${name.charAt(0).toUpperCase()}${name.slice(1)}Changed`;
    return function (...args) {
        this[defaultName] && this[defaultName](...args);
    };
}
function normalizeDescriptor(name, descriptor) {
    return {
        type: descriptor.call ? descriptor : descriptor.type,
        onChange: descriptor.onChange === true
            ? createChangeCallback(name)
            : descriptor.onChange
    };
}
function defineProp(prototype, name, propertyDescriptor) {
    Object.defineProperty(prototype, name, {
        get() {
            return this.__props[name];
        },
        set(newValue) {
            const oldValue = this[name];
            this.__props[name] = newValue;
            if (this.rendered && oldValue !== newValue) {
                if (propertyDescriptor.onChange)
                    propertyDescriptor.onChange.call(this, newValue, oldValue);
                this.update();
            }
        }
    });
}
function defineProps(constructor) {
    if (!constructor.__attrs) {
        const properties = constructor.properties || {};
        const attrsMap = Object.create(null);
        const props = Object.create(null);
        const proto = constructor.prototype;
        for (const propertyName in properties) {
            const propertyDescriptor = normalizeDescriptor(propertyName, properties[propertyName]);
            const attrName = propertyName
                .replace(/([a-z])([A-Z])/g, '$1-$2')
                .toLowerCase();
            attrsMap[attrName] = propertyName;
            props[propertyName] = propertyDescriptor;
            defineProp(proto, propertyName, propertyDescriptor);
        }
        constructor.__attrs = attrsMap;
        constructor.__props = props;
    }
    return Object.keys(constructor.__attrs);
}
export function withProps(Base) {
    return class extends Base {
        constructor() {
            super(...arguments);
            this.__props = Object.create(null);
        }
        static get observedAttributes() {
            return defineProps(this);
        }
        attributeChangedCallback(name, _, newValue) {
            const { __attrs: attributes, __props: properties } = (this.constructor);
            if (properties && attributes && name in properties) {
                const propName = attributes[name];
                this[propName] = properties[propName].type(newValue);
            }
        }
    };
}
